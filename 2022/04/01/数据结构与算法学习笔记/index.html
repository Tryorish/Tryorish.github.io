<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法学习笔记 | Tryorish</title><meta name="author" content="Tryorish"><meta name="copyright" content="Tryorish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面的话数据结构与算法的学习需要长时间的积累与沉淀，不可能短时间精通。本篇主要记录自己数据结构与算法受苦的心路历程。长路漫漫，希望你能坚持下去。 需要刷的课：  预备知识  实战！   一、新手村1、认识复杂度和简单排序算法 时间复杂度 在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法学习笔记">
<meta property="og:url" content="http://example.com/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Tryorish">
<meta property="og:description" content="写在前面的话数据结构与算法的学习需要长时间的积累与沉淀，不可能短时间精通。本篇主要记录自己数据结构与算法受苦的心路历程。长路漫漫，希望你能坚持下去。 需要刷的课：  预备知识  实战！   一、新手村1、认识复杂度和简单排序算法 时间复杂度 在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/hai.jpg">
<meta property="article:published_time" content="2022-04-01T11:59:30.000Z">
<meta property="article:modified_time" content="2022-04-22T13:01:49.168Z">
<meta property="article:author" content="Tryorish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/hai.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-04-22 21:01:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/iconfont.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tit.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/hai.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tryorish</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-01T11:59:30.000Z" title="发表于 2022-04-01 19:59:30">2022-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-22T13:01:49.168Z" title="更新于 2022-04-22 21:01:49">2022-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>数据结构与算法的学习需要长时间的积累与沉淀，不可能短时间精通。本篇主要记录自己数据结构与算法受苦的心路历程。长路漫漫，希望你能坚持下去。</p>
<p>需要刷的课：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nJ411V7bd">预备知识</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13g41157hK?p=2">实战！</a></p>
</li>
</ul>
<h1 id="一、新手村"><a href="#一、新手村" class="headerlink" title="一、新手村"></a>一、新手村</h1><h2 id="1、认识复杂度和简单排序算法"><a href="#1、认识复杂度和简单排序算法" class="headerlink" title="1、认识复杂度和简单排序算法"></a>1、认识复杂度和简单排序算法</h2><ul>
<li><p>时间复杂度</p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>时间复杂性</strong>，又称<strong>时间复杂度</strong>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95">算法</a>的<strong>时间复杂度</strong>是一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0">函数</a>，它定性描述该算法的运行时间。这是一个代表算法输入值的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%95%BF%E5%BA%A6/1584632">长度</a>的函数。时间复杂度常用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7O%E7%AC%A6%E5%8F%B7">大O符号</a>表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B8%90%E8%BF%91">渐近</a>的，亦即考察输入值大小趋近<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%A0%E7%A9%B7/8284883">无穷</a>时的情况。</p>
</li>
<li><p>选择排序</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minIndex = (arr[minIndex] &gt; arr[j]) ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>冒泡排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过异或方式交换，注意此时i和j不能是同一个位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>插入排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//像斗地主起牌时给牌排序那样，从当前位置往前看，选择合适的地方插进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>二分查找</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSExist</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);<span class="comment">//注意(L+R)/2可能会造成int数据溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>二分法变式1：  在一个数组上，找满足&gt;=value的最左位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSNearLeft</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在arr上，找满足&gt;=value的最左位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">                index = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>二分法变式2：局部最小值问题                                     </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindOneLessValueIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如若两头有局部最小值，则返回索引</span></span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证凹的趋势</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于异或操作练习</li>
</ul>
<p>​        二进制位上不同为1相同为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenTimesOddTimes</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一种数出现奇数次，其他数出现偶数次，输出这个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> eO = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur : arr) &#123;</span><br><span class="line">            eO ^= cur;<span class="comment">//遍历异或得到出现奇数次的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(eO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两种数出现奇数次，其他数出现偶数次，输出这两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> eO = <span class="number">0</span>, eOhasOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curNum : arr) &#123;</span><br><span class="line">            eO ^= curNum;<span class="comment">//遍历异或得到这两个数的异或</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个数不相等，其异或结果不为0，则必有其中一位上为1</span></span><br><span class="line">        <span class="keyword">int</span> rightOne = eO &amp; (~eO + <span class="number">1</span>);<span class="comment">//原码和补码进行按位与得到最右位的1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur : arr) &#123;</span><br><span class="line">            <span class="comment">//对最右位为1的数遍历异或，得到其中一个数</span></span><br><span class="line">            <span class="keyword">if</span> ((cur &amp; rightOne) == rightOne) &#123;</span><br><span class="line">                eOhasOne ^= cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(eOhasOne + <span class="string">&quot; &quot;</span> + (eO ^ eOhasOne));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>递归求最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMax</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[L];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> leftMax = process(arr, L, mid );</span><br><span class="line">        <span class="keyword">int</span> rightMax = process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jmh1996/article/details/82827579">补充知识：Master定理</a></li>
</ul>
<h2 id="2、认识O-NlogN-的排序"><a href="#2、认识O-NlogN-的排序" class="headerlink" title="2、认识O(NlogN)的排序"></a>2、认识O(NlogN)的排序</h2><ul>
<li>归并排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, l, mid);<span class="comment">//左半部分有序</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, r);<span class="comment">//右半部分有序</span></span><br><span class="line">        merge(arr, l, mid, r);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];<span class="comment">//辅助数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = l;</span><br><span class="line">        <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;<span class="comment">//当两个子数组都不越界时，把较小的值依次放入辅助数组中</span></span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当一个子数组放完时，把另一个子数组中剩下的值放入辅助数组中</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把辅助数组中的值拷贝到原数组中，此时已排好序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help.length; j++) &#123;</span><br><span class="line">            arr[l + j] = help[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>归并排序扩展1：小和问题</p>
<p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, l, mid)<span class="comment">//左子数组小和</span></span><br><span class="line">                + mergeSort(arr, mid + <span class="number">1</span>, r)<span class="comment">//右子数组小和</span></span><br><span class="line">                + merge(arr, l, mid, r);<span class="comment">//合并小和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = l;</span><br><span class="line">        <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每一次归并使子数组有序时，累加了小和，合并和内部小和就不用再考虑了，做到不重不漏</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;<span class="comment">//当前数小于右子数组的数，累加小和</span></span><br><span class="line">            res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help.length; j++) &#123;</span><br><span class="line">            arr[l + j] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>荷兰国旗问题</p>
<p>给定一个数和一个数组，小于该数的放左边，等于放中间，大于该数的放右边</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetherlandsFlag</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = l - <span class="number">1</span>;<span class="comment">//小于p的区域</span></span><br><span class="line">        <span class="keyword">int</span> more = r + <span class="number">1</span>;<span class="comment">//大于p的区域</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; more) &#123;<span class="comment">//若当前数没有撞到大于p区域</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; p) &#123;<span class="comment">//当前数小于p，less区前移，该数移到less区</span></span><br><span class="line">                swap(arr, ++less, l++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; p) &#123;<span class="comment">//当前数大于p，more区后退，当前数移到more区         </span></span><br><span class="line">                swap(arr, --more, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前数等于p，判断下一个数</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more - <span class="number">1</span>&#125;;<span class="comment">//返回等于p的区域索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>快速排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;<span class="comment">//随机选一个数放在尾端，以该数为准进行分块</span></span><br><span class="line">            swap(arr, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">            <span class="keyword">int</span>[] p = partition(arr, l, r);<span class="comment">//分成三部分</span></span><br><span class="line">            quickSort(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);<span class="comment">//左部分有序</span></span><br><span class="line">            quickSort(arr, p[<span class="number">0</span>] + <span class="number">1</span>, r);<span class="comment">//有部分有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                swap(arr, ++less, l++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r]) &#123;</span><br><span class="line">                swap(arr, --more, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>堆</li>
</ul>
<blockquote>
<p>1.堆结构就是用数组实现的完全二叉树结构</p>
<p>2.完全二叉树中如果每颗子树的最大值都在顶部就是大根堆</p>
<p>3.完全二叉树中如果每颗子树的最小值都在顶部就是小根堆</p>
<p>4.堆结构的heapInsert与heapify操作</p>
<p>5.堆结构的增大和减少</p>
<p>6.优先级队列结构，就是堆结构</p>
</blockquote>
<ul>
<li>堆排序</li>
</ul>
<blockquote>
<p>1.先让整个数组都变成大根堆结构，建立堆的过程：</p>
<p>​        1)从上到下的方法，时间复杂度为O（N*logN)</p>
<p>​        2)从下到上的方法，时间复杂度为O（N）</p>
<p>2.把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN)</p>
<p>3.堆的大小减小成0之后，排序完成</p>
</blockquote>
<p>​    代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;<span class="comment">//堆的大小</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);<span class="comment">//把堆顶元素拿走，堆中最后一个数放入堆顶，堆大小减1</span></span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;<span class="comment">//当堆中还有数时</span></span><br><span class="line">            heapify(arr, <span class="number">0</span>, heapSize);<span class="comment">//调整堆</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把index位置上的数放入大根堆中，构建堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;<span class="comment">//当当前数大于父亲节点时</span></span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);<span class="comment">//和父亲节点交换</span></span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123;<span class="comment">//当有左孩子时</span></span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>]</span><br><span class="line">                    ? left + <span class="number">1</span> : left;<span class="comment">//判断左右孩子哪个大</span></span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;<span class="comment">//判断大孩子和父亲哪个大</span></span><br><span class="line">            <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果父亲大，满足大根堆结构，退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, largest, index);<span class="comment">//孩子中有比父亲大的，交换</span></span><br><span class="line">            index = largest;<span class="comment">//再从孩子位置开始判断孩子的孩子</span></span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>堆排序扩展题：</li>
</ul>
<p>​    已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过K，并且K相对于数组来说比较小，请选择一个合适的排序算法堆这个数据进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortArrayDistanceLessK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortArrDistanceLessK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();<span class="comment">//创建堆结构</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index &lt; Math.min(arr.length, k); index++) &#123;</span><br><span class="line">            heap.add(arr[index]);<span class="comment">//取k个数放入堆中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将剩下的数逐个放入堆中，保持移动距离始终不超过k</span></span><br><span class="line">        <span class="keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;</span><br><span class="line">            heap.add(arr[index]);</span><br><span class="line">            arr[i] = heap.poll();<span class="comment">//从堆顶弹出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将堆中剩下的数放入数组中</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            arr[i++] = heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3、详解桶排序及排序内容大总结"><a href="#3、详解桶排序及排序内容大总结" class="headerlink" title="3、详解桶排序及排序内容大总结"></a>3、详解桶排序及排序内容大总结</h2><ul>
<li>桶排序思想下的排序</li>
</ul>
<blockquote>
<p>1）计数排序</p>
<p>2）基数排序</p>
<p>分析：</p>
<p>1）桶排序思想下的排序都是不基于比较的排序</p>
<p>2）时间复杂度为O（N），额外空间复杂度为O（M）</p>
<p>3）应用范围有限，需要样本的数据状况满足桶的划分</p>
</blockquote>
<ul>
<li>计数排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">        &#125;<span class="comment">//找出所给数的最大值max</span></span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];<span class="comment">//创建max+1个桶,一个桶对应数组中的一个值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bucket[arr[i]]++;<span class="comment">//一种数每出现一次，该数对应的桶加一，记录该数出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;<span class="comment">//遍历桶</span></span><br><span class="line">            <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[i++] = j;<span class="comment">//从第一个桶开始，该桶记录的频次为多少，就说明有几个该桶代表的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>基数排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">papublic <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        radixSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, maxbits(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求数组中最大值的位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxbits</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(arr[i], max);<span class="comment">//找出最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//记录位数</span></span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取某一位上的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;<span class="comment">//0~9</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[end - begin + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; digit; d++) &#123;<span class="comment">//遍历所有位，出入桶的次数</span></span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line">            <span class="comment">//记录某一位上所有数出现的次数</span></span><br><span class="line">            <span class="keyword">for</span> (i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                j = getDigit(arr[i], d);</span><br><span class="line">                count[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算前缀和，即某一位上小于等于该数的个数</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) &#123;</span><br><span class="line">                count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右往左遍历数组，按前缀和-1放入桶中，后进后出，这样可以保证不打乱上一次排的顺序</span></span><br><span class="line">            <span class="keyword">for</span> (i = end; i &gt;= begin; i--) &#123;</span><br><span class="line">                j = getDigit(arr[i], d);</span><br><span class="line">                bucket[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">                count[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出桶，此时数组按某一位从小到大已排好序</span></span><br><span class="line">            <span class="keyword">for</span> (i = begin, j = <span class="number">0</span>; i &lt;= end; i++, j++) &#123;</span><br><span class="line">                arr[i] = bucket[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>烩菜</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>O(N2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(N2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(N2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(N*logN)</td>
<td>O(N)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(N*logN)</td>
<td>O(logN)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(N*logN)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>同样值的个体之间，如果不因为排序而改变相对次序，这个排序就是有稳定性的，否则就没有</p>
<p>不具备稳定性的排序：</p>
<p>选择排序、快速排序、堆排序</p>
<p>具备稳定性的排序：<br>冒泡排序、插入排序、归并排序、一切桶排序思想下的排序</p>
<p>目前没有找到时间复杂度O(N*logN)  ，额外空间复杂度O(1),又稳定的排序</p>
</blockquote>
<h2 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h2><ul>
<li>哈希表的简单介绍</li>
</ul>
<blockquote>
<p>1）哈希表在使用层面上可以理解为一种集合结构</p>
<p>2）如果只有key，没有伴随数据value，可以使用HashSet结构</p>
<p>3）如果既有key，又有伴随数据value，可以使用HashMap结构</p>
<p>4）有无伴随数据，是HashSet和HashMap唯一的区别，底层的实际结构是一回事</p>
<p>5）使用哈希表增（put）、删（remove）、改（put）、和查（get）的操作，可以认为时间复杂度为O（1），但是常数时间比较大</p>
<p>6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小</p>
<p>7）放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用就是这个东西内存地址的大小</p>
</blockquote>
<ul>
<li>有序表的简单介绍</li>
</ul>
<blockquote>
<p>1）有序表在使用层面上可以理解为一种集合结构</p>
<p>2）如果只有key，没有伴随数据value，可以使用TreeSet结构</p>
<p>3）如果既有key，又有伴随数据value，可以使用TreeMap结构</p>
<p>4）有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事</p>
<p>5)有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织</p>
<p>6）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同</p>
<p>7）放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小</p>
<p>8）放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用就是这个东西内存地址的大小</p>
<p>9）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度</p>
</blockquote>
<ul>
<li>有序表固定操作</li>
</ul>
<blockquote>
<ol>
<li><p>void put(K key,V value): 将一个(key,value)记录加入到表中，或者将key对应的value更新</p>
</li>
<li><p>V get(K key): 根据给定的key，查询value并返回</p>
</li>
<li><p>void remove(K key): 移除key的记录</p>
</li>
<li><p>boolean containsKey(K key): 查询是否有关于key的记录</p>
</li>
<li><p>K firstKey(): 返回所有键值的排序结果中，最左(最小)的那个</p>
</li>
<li><p>K lastKey(): 返回所有键值的排序结果中，最右(最小)的那个</p>
</li>
<li><p>K floorKey(K key): 如果表中存入过key，返回key，否则返回所有键值的排序结果中，key的前一个</p>
</li>
<li><p>K ceilingKey(K key): 如果表中存入过key，返回key，否则返回所有键值的排序结果中，key的后一个 </p>
</li>
</ol>
<p>以上所有操作时间复杂度都是O(logN)，N为有序表含有的记录数</p>
</blockquote>
<ul>
<li>单链表节点结构</li>
</ul>
<blockquote>
<p>Class Node<V>{</V></p>
<p>​        V value;</p>
<p>​        Node next;</p>
<p>}</p>
<p>由以上结构的节点依次连接起来所形成的链叫单链表结构</p>
</blockquote>
<ul>
<li>双链表的结点结构</li>
</ul>
<blockquote>
<p>Class Node<V>{</V></p>
<p>​        V value;</p>
<p>​        Node next;</p>
<p>​        Node last;</p>
<p>}</p>
<p>由以上结构的节点依次连接起来所形成的链叫双链表结构</p>
</blockquote>
<p>单链表和双链表结构只需要给定一个头节点head，就可以找到剩下的所有节点</p>
<ul>
<li>反转单向和双向链表</li>
</ul>
<p>​    如果链表长度为N，时间复杂度要求为O(N),额外空间复杂度要求为O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转单向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">        DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">        DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            head.last = next;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>打印两个有序链表的公共部分</p>
<p>给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。要求：如果两个链表长度之和为N，时间复杂度要求为O(N),额外空间复杂度要求为O(1)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintCommonPart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Common Part: &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1.value &lt; head2.value) &#123;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(head1.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>面试时链表解题的方法论</li>
</ul>
<blockquote>
<ol>
<li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</li>
<li>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</li>
</ol>
<ul>
<li>重要技巧</li>
</ul>
<ol>
<li>额外数据结构记录（哈希表等）</li>
<li>快慢指针</li>
</ol>
</blockquote>
<ul>
<li><p>判断一个链表是否为回文结构</p>
<p>给定一个单链表的头节点head，请判断该链表是否为回文结构。要求：如果链表长度为N，时间复杂度要求为O(N),额外空间复杂度要求为O(1)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">isPalindromeList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//need n extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//need n/2 extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node right = head.next;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need O(1) extra space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        Node n1 = head;</span><br><span class="line">        Node n2 = head;</span><br><span class="line">        <span class="keyword">while</span> (n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n1.next;<span class="comment">//右侧部分第一个节点</span></span><br><span class="line">        n1.next = <span class="keyword">null</span>;</span><br><span class="line">        Node n3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//反转右侧链表</span></span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n3 = n2.next;<span class="comment">//保存下一个节点</span></span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1 = n2;<span class="comment">//n1右移</span></span><br><span class="line">            n2 = n3;<span class="comment">//n2右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        n3 = n1;<span class="comment">//记录尾节点</span></span><br><span class="line">        n2 = head;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//比较左右链表</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1.value != n2.value) &#123;</span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复原链表</span></span><br><span class="line">        n1 = n3.next;</span><br><span class="line">        n3.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n2 = n1.next;</span><br><span class="line">            n1.next = n3;</span><br><span class="line">            n3 = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>复制含有随机指针节点的链表</li>
</ul>
<blockquote>
<p>一种特殊的单链表节点类描述如下</p>
<p>class Node{</p>
<p>​        int value;</p>
<p>​        Node next;</p>
<p>​        Node rand;</p>
<p>​        Node(int val){</p>
<p>​            value=val;</p>
<p>​    }</p>
<p>}</p>
<p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。要求：时间复杂度O(N),额外空间复杂度O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyListWithRandom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node rand;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//笔试解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRandom1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;<span class="comment">//创建新节点，并放入HashMap中</span></span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;<span class="comment">//拷贝</span></span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回拷贝链表的头指针</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//面试解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="comment">//copy node and link to every node</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">            cur.next.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node curCopy;</span><br><span class="line">        <span class="comment">//set copy node rand</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next.next;</span><br><span class="line">            curCopy = cur.next;</span><br><span class="line">            curCopy.rand = cur.rand != <span class="keyword">null</span> ? cur.rand.next : <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node res = head.next;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//split</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next.next;</span><br><span class="line">            curCopy = cur.next;</span><br><span class="line">            cur.next = next;</span><br><span class="line">            curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将单向链表分为三部分</p>
<p>给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点【进阶】在实现原问题的基础上保证稳定性（相对顺序不变）时间复杂度O(N),额外空间复杂度O(1)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallerEqualBigger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="comment">//遍历求出链表长度</span></span><br><span class="line">        Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeArr.length; i++) &#123;</span><br><span class="line">            nodeArr[i] = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="comment">//把节点存到数组中</span></span><br><span class="line">        arrPartition(nodeArr, pivot);<span class="comment">//划分</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nodeArr.length; i++) &#123;<span class="comment">//链接新链表</span></span><br><span class="line">            nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index != big) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">                swap(nodeArr, index++, ++small);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nodeArr, index, --big);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        Node temp = nodeArr[a];</span><br><span class="line">        nodeArr[a] = nodeArr[b];</span><br><span class="line">        nodeArr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进阶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">        Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">        Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">        Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">        Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">        Node bH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">        Node bT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">        Node next = <span class="keyword">null</span>; <span class="comment">// save next node</span></span><br><span class="line">        <span class="comment">// every node distributed to three lists</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sH = head;</span><br><span class="line">                    sT = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sT.next = head;</span><br><span class="line">                    sT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    eH = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    eT.next = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bH = head;</span><br><span class="line">                    bT = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bT.next = head;</span><br><span class="line">                    bT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// small and equal reconnect</span></span><br><span class="line">        <span class="keyword">if</span> (sH != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sT.next = eH;</span><br><span class="line">            eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//all reconnect</span></span><br><span class="line">        <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eT.next = bH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>两个单链表相交的一系列问题</p>
<p>给定两个可能有环也可能无环的单链表，头节点head1和head2.请实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交，返回null。【要求】如果两个链表长度之和为N，时间复杂度请达到O（N），额外空间复杂度为O(1)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstIntersectNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回第一个相交节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到进入循环的第一个节点</span></span><br><span class="line">        Node loop1 = getLoopNode(head1);</span><br><span class="line">        Node loop2 = getLoopNode(head2);</span><br><span class="line">        <span class="comment">//两条链表都无环</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两条链表都有环</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一条有环，一条无环，必不可能相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回进入循环的第一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个节点无法成环</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node n1 = head.next;<span class="comment">//慢指针</span></span><br><span class="line">        Node n2 = head.next.next;<span class="comment">//快指针</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            <span class="comment">//不成环情况</span></span><br><span class="line">            <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若有环，让快慢指针相遇</span></span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = head;<span class="comment">//慢指针不动，快指针指向头节点</span></span><br><span class="line">        <span class="comment">//快慢指针一起移动，相遇时必定是入环节点</span></span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回两个无环链表第一个相交节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur1 = head1;</span><br><span class="line">        Node cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得出两个链表长度差值</span></span><br><span class="line">        <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cur1指向长链表的头节点</span></span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="comment">//长链表先走差值</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长链表走完差值后两个指针一起走直至相遇或者都为null</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回两个有环链表的第一个相交节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">        Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">        Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//入环节点相同</span></span><br><span class="line">        <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">            cur1 = head1;</span><br><span class="line">            cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur1 = loop1.next;</span><br><span class="line">            <span class="keyword">while</span> (cur1 != loop1) &#123;<span class="comment">//入环节点不同，让一个指针走环</span></span><br><span class="line">                <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> loop1;<span class="comment">//碰到另一个入环节点，说明相交，返回一个入环节点即可</span></span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//两条链表各自成环，不相交</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、二叉树"><a href="#5、二叉树" class="headerlink" title="5、二叉树"></a>5、二叉树</h2><ul>
<li>二叉树节点结构</li>
</ul>
<blockquote>
<p>class Node<V>{</V></p>
<p>​        V value;</p>
<p>​        Node left;</p>
<p>​        Node right;</p>
<p>}</p>
</blockquote>
<ul>
<li>用递归和非递归两种方式实现二叉树的先序、中序、后序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreInPosTraversal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序递归遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrderRecur(head.left);</span><br><span class="line">        preOrderRecur(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序递归遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderRecur(head.left);</span><br><span class="line">        System.out.println(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrderRecur(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序递归遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        posOrderRecur(head.left);</span><br><span class="line">        posOrderRecur(head.right);</span><br><span class="line">        System.out.println(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序非递归遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;pre-order: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.add(head);<span class="comment">//根节点进栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.println(head.value + <span class="string">&quot; &quot;</span>);<span class="comment">//弹出根节点并打印</span></span><br><span class="line">                <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;<span class="comment">//如果有左孩子，左孩子进栈</span></span><br><span class="line">                    stack.push(head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;<span class="comment">//如果有右孩子，右孩子进栈</span></span><br><span class="line">                    stack.push(head.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序非递归遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;in-order: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(head);</span><br><span class="line">                    head = head.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    head = stack.pop();</span><br><span class="line">                    System.out.println(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    head = head.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序非递归遍历二叉树1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            head = s1.pop();</span><br><span class="line">            s2.push(head);<span class="comment">//2栈进栈为根右左</span></span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2栈出栈为左右根即后序</span></span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(s2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序非递归遍历二叉树2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            stack.push(head);</span><br><span class="line">            Node c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                c = stack.peek();<span class="comment">//栈顶元素</span></span><br><span class="line">                <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; head != c.left &amp;&amp; head != c.right) &#123;</span><br><span class="line">                    stack.push(c.left);<span class="comment">//有左孩子且左孩子未进过栈，左孩子进栈</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; head != c.right) &#123;</span><br><span class="line">                    stack.push(c.right);<span class="comment">//有右孩子且右孩子未进过栈，右孩子进栈</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(stack.pop().value + <span class="string">&quot; &quot;</span>);<span class="comment">//弹出栈顶元素</span></span><br><span class="line">                    head = c;<span class="comment">//记录栈顶元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>二叉树宽度优先遍历（常见题目：求一颗二叉树的宽度）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1<span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMaxWidth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxWidth</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;<span class="comment">//最大宽度</span></span><br><span class="line">        <span class="keyword">int</span> curWidth = <span class="number">0</span>;<span class="comment">//当前宽度</span></span><br><span class="line">        <span class="keyword">int</span> curLevel = <span class="number">0</span>;<span class="comment">//当前层</span></span><br><span class="line">        HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        Node node = <span class="keyword">null</span>;</span><br><span class="line">        Node left = <span class="keyword">null</span>;</span><br><span class="line">        Node right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.pop();</span><br><span class="line">            left = node.left;</span><br><span class="line">            right = node.right;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;<span class="comment">//左孩子进Map，进队列</span></span><br><span class="line">                levelMap.put(left, levelMap.get(node) + <span class="number">1</span>);</span><br><span class="line">                queue.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;<span class="comment">//右孩子进Map，进队列</span></span><br><span class="line">                levelMap.put(right, levelMap.get(node) + <span class="number">1</span>);</span><br><span class="line">                queue.add(right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (levelMap.get(node) == curLevel) &#123;</span><br><span class="line">                curWidth++;<span class="comment">//弹出节点为当前层，宽度加1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//换层，层次加一，宽度更新，最大宽度更新</span></span><br><span class="line">                curLevel++;</span><br><span class="line">                curWidth = <span class="number">1</span>;</span><br><span class="line">                maxWidth = Math.max(maxWidth, curWidth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一层宽度比较</span></span><br><span class="line">        <span class="keyword">return</span> maxWidth = Math.max(maxWidth, curWidth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>判断一颗二叉树是否是搜索二叉树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Node&gt; inOrderList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        process(head, inOrderList);<span class="comment">//中序遍历搜索树放入链表中</span></span><br><span class="line">        <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Node cur : inOrderList) &#123;<span class="comment">//判断链表是否为升序</span></span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= cur.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node node, LinkedList&lt;Node&gt; inOrderList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(node.left, inOrderList);</span><br><span class="line">        inOrderList.add(node);<span class="comment">//中序遍历添加</span></span><br><span class="line">        process(node.right, inOrderList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>判断一颗二叉树是否为完全二叉树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsCBT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">        Node l = <span class="keyword">null</span>;</span><br><span class="line">        Node r = <span class="keyword">null</span>;</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            head = queue.pop();</span><br><span class="line">            l = head.left;</span><br><span class="line">            r = head.right;</span><br><span class="line">            <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//若为叶子节点的同时有孩子，或者有右孩子的同时没有左孩子，不是完全二叉树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leaf = <span class="keyword">true</span>;<span class="comment">//此后节点应均为叶子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>判断一棵二叉树是否为平衡二叉树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalancedTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(head).isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回值类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnType</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReturnType</span><span class="params">(<span class="keyword">boolean</span> isB, <span class="keyword">int</span> hei)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isBalanced = isB;</span><br><span class="line">            <span class="keyword">this</span>.height = hei;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnType <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnType(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别向左右子树要数据</span></span><br><span class="line">        ReturnType leftData = process(x.left);</span><br><span class="line">        ReturnType rightData = process(x.right);</span><br><span class="line">        <span class="comment">//高度为子树最大高度加上本节点高度</span></span><br><span class="line">        <span class="keyword">int</span> height = Math.max(leftData.height, rightData.height) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当左右子树均为平衡树且高度差小于2时为平衡树</span></span><br><span class="line">        <span class="keyword">boolean</span> isBalanced = leftData.isBalanced &amp;&amp; rightData.isBalanced</span><br><span class="line">                &amp;&amp; Math.abs(leftData.height - rightData.height) &lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnType(isBalanced, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给定两个二叉树节点node1和node2，找到他们的最低公共祖先节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestCommonAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head == o1 || head == o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;<span class="comment">//遇到两节点或null时，返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        Node left = lowestCommonAncestor(head.left, o1, o2);</span><br><span class="line">        Node right = lowestCommonAncestor(head.right, o1, o2);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;<span class="comment">//左右返回值为o1,o2,此时该节点为最低公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若一个节点为另一个节点父节点，则该点为最低公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数（在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessorNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node parent;<span class="comment">//指向父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNODE</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            <span class="comment">//当有父节点且该节点不为父节点左孩子时，向上回溯</span></span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; node != parent.left) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直至左子树结束到根或到达头节点</span></span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回某个根节点右子树的最左</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>二叉树序列化和反序列化</p>
<p>就是内存里的一棵二叉树如何变成字符串形式，又如何从字符串形式变成内存里的树</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeAndReconstructTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = head.value + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        res += serialByPre(head.left);</span><br><span class="line">        res += serialByPre(head.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span> </span>&#123;</span><br><span class="line">        String[] values = preStr.split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != values.length; i++) &#123;</span><br><span class="line">            queue.offer(values[i]);<span class="comment">//放入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String value = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">        head.left = reconPreOrder(queue);</span><br><span class="line">        head.right = reconPreOrder(queue);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>折纸问题</p>
<p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对着2次，压出折痕然后展开，此时有三条折痕，从上到下依次是凹凹凸。给定一个输入参数N，代表纸条都从下边向上边连续对着N次。请从上到下打印所有折痕的方向。例如：N=1时，打印 down，N=2时，打印 down down up</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaperFolding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        printProcess(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(down ? <span class="string">&quot;down &quot;</span> : <span class="string">&quot;up &quot;</span>);</span><br><span class="line">        printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6、图"><a href="#6、图" class="headerlink" title="6、图"></a>6、图</h2><ul>
<li><p>图的存储方式</p>
<ol>
<li>邻接表</li>
<li>邻接矩阵</li>
</ol>
</li>
<li><p>通用模板</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> HashMap&lt;Integer,Node&gt; nodes;</span><br><span class="line">	<span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span></span>&#123;</span><br><span class="line">		nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;<span class="comment">//节点值</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> in;<span class="comment">//入度</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> out;<span class="comment">//出度</span></span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		out = <span class="number">0</span>;</span><br><span class="line">		nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> weight;<span class="comment">//权</span></span><br><span class="line">    <span class="keyword">public</span> Node from;<span class="comment">//值来的点</span></span><br><span class="line">   	<span class="keyword">public</span> Node to;<span class="comment">//指向的点</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.weight = weight;</span><br><span class="line">	<span class="keyword">this</span>.from = from;</span><br><span class="line">	<span class="keyword">this</span>.to = to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>模板转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span> </span>&#123;</span><br><span class="line">    Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        Integer weight = matrix[i][<span class="number">0</span>];</span><br><span class="line">        Integer from = matrix[i][<span class="number">1</span>];</span><br><span class="line">        Integer to = matrix[i][<span class="number">2</span>];	</span><br><span class="line">        <span class="keyword">if</span>(!graph.nodes.containskey(from))&#123;</span><br><span class="line">            graph.nodes.put(from,<span class="keyword">new</span> Node(from));</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="keyword">if</span>(!graph.nodes.containskey(to))&#123;</span><br><span class="line">            graph.nodes.put(to,<span class="keyword">new</span> Node(to));</span><br><span class="line">        &#125;</span><br><span class="line">        Node fromNode = graph.nodes.get(from);</span><br><span class="line">        Node toNode = graph.nodes.get(to);</span><br><span class="line">        Edge newEdge = <span class="keyword">new</span> Edge(weight,fromNode,toNode);</span><br><span class="line">        fromNode.nexts.add(toNode);</span><br><span class="line">        fromNode.out++;</span><br><span class="line">      	toNode.in++;</span><br><span class="line">        fromNOde.edges.add(newEdge);</span><br><span class="line">        graph.edges.add(newEdge);</span><br><span class="line">   	&#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>图的宽度优先遍历<ol>
<li>利用队列实现</li>
<li>从源节点开始依次按照宽度进队列，然后弹出</li>
<li>每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</li>
<li>直到队列变为空</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//保证不重复</span></span><br><span class="line">        queue.add(node);</span><br><span class="line">        map.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.contains(next)) &#123;</span><br><span class="line">                    map.add(next);</span><br><span class="line">                    queue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>深度优先遍历<ol>
<li>利用栈实现</li>
<li>从源节点开始把节点按照深度放入栈，然后弹出</li>
<li>每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</li>
<li>直到栈变为空</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.println(next.value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>拓扑排序算法</p>
<p>适用范围：要求有向图，且有入度为0的节点，且没有环</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologySort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">sortedTopology</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//入度为0的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">            inMap.put(node, node.in);</span><br><span class="line">            <span class="keyword">if</span> (node.in == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroInQueue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">            Node cur = zeroInQueue.poll();<span class="comment">//每弹出一个点，消除他散发的边</span></span><br><span class="line">            result.add(cur);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroInQueue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>最小生成树之kruskal算法（学到并查集后再来看）</p>
<p>适用范围：要求无向图</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">//undirected graph only</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Union-Find Set</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; rankMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">            rankMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">findFather</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">            Node father = fatherMap.get(n);</span><br><span class="line">            <span class="keyword">if</span> (father != n) &#123;</span><br><span class="line">                father = findFather(father);</span><br><span class="line">            &#125;</span><br><span class="line">            fatherMap.put(n, father);</span><br><span class="line">            <span class="keyword">return</span> father;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">            fatherMap.clear();</span><br><span class="line">            rankMap.clear();</span><br><span class="line">            <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">                fatherMap.put(node, node);</span><br><span class="line">                rankMap.put(node, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node aFather = findFather(a);</span><br><span class="line">            Node bFather = findFather(b);</span><br><span class="line">            <span class="keyword">if</span> (aFather != bFather) &#123;</span><br><span class="line">                <span class="keyword">int</span> aFrank = rankMap.get(aFather);</span><br><span class="line">                <span class="keyword">int</span> bFrank = rankMap.get(bFather);</span><br><span class="line">                <span class="keyword">if</span> (aFrank &lt;= bFrank) &#123;</span><br><span class="line">                    fatherMap.put(aFather, bFather);</span><br><span class="line">                    rankMap.put(bFather, aFrank + bFrank);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fatherMap.put(bFather, aFather);</span><br><span class="line">                    rankMap.put(aFather, aFrank + bFrank);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">        unionFind.makeSets(graph.nodes.values());</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : graph.edges) &#123;</span><br><span class="line">            priorityQueue.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            Edge edge = priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123;</span><br><span class="line">                result.add(edge);</span><br><span class="line">                unionFind.union(edge.from, edge.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>最小生成树之prim算法</p>
<p>适用范围：要求无向图</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">prim</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(node)) &#123;</span><br><span class="line">                set.add(node);</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : node.edges) &#123;</span><br><span class="line">                    priorityQueue.add(edge);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                    Edge edge = priorityQueue.poll();</span><br><span class="line">                    Node toNode = edge.to;</span><br><span class="line">                    <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                        set.add(toNode);</span><br><span class="line">                        result.add(edge);</span><br><span class="line">                        <span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                            priorityQueue.add(nextEdge);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请保证graph是连通图</span></span><br><span class="line">    <span class="comment">// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路</span></span><br><span class="line">    <span class="comment">// 返回值是最小连通图的路径之和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] distances = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            distances[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minPath = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &lt; minPath) &#123;</span><br><span class="line">                    minPath = distances[j];</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">            visit[minIndex] = <span class="keyword">true</span>;</span><br><span class="line">            sum += minPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &gt; graph[minIndex][j]) &#123;</span><br><span class="line">                    distances[j] = graph[minIndex][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>最短路径之Dijkstra算法</p>
<p>适用范围：没有权值为负数的边</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从源点到某点的最小距离</span></span><br><span class="line">        HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        distanceMap.put(head, <span class="number">0</span>);</span><br><span class="line">        HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">        <span class="keyword">while</span> (minNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> distance = distanceMap.get(minNode);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                    distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">                &#125;</span><br><span class="line">                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">            selectedNodes.add(minNode);</span><br><span class="line">            minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distanceMap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(HashMap&lt;Node, Integer&gt; distanceMap,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;</span><br><span class="line">        Node minNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">            Node node = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">                minNode = node;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7、前缀树和贪心"><a href="#7、前缀树和贪心" class="headerlink" title="7、前缀树和贪心"></a>7、前缀树和贪心</h2><ul>
<li><p>前缀树</p>
<p>一个字符串类型的数组arr1，另一个字符串类型的数组arr2。arr2中有哪些字符，是arr1中出现的？请打印。arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印。arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印arr2中出现次数最大的前缀</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TireTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;<span class="comment">//有多少字符串以此为前缀</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;<span class="comment">//有多少字符串以此为结尾</span></span><br><span class="line">        <span class="keyword">public</span> TrieNode[] nexts;<span class="comment">//字符节点数组</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//字符索引</span></span><br><span class="line">                <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.nexts[index] = <span class="keyword">new</span> TrieNode();<span class="comment">//如果为新节点，则创建</span></span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];<span class="comment">//后移</span></span><br><span class="line">                node.path++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">                TrieNode node = root;</span><br><span class="line">                <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                    index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--node.nexts[index].path == <span class="number">0</span>) &#123;</span><br><span class="line">                        node.nexts[index] = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.nexts[index];</span><br><span class="line">                &#125;</span><br><span class="line">                node.end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有多少串以该串为前缀</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>贪心算法</li>
</ul>
<blockquote>
<p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法叫做贪心算法</p>
<p>也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解</p>
<p>局部最优？-〉整体最优</p>
<p>贪心算在笔试时解题套路</p>
<ol>
<li>实现一个不依靠贪心策略的解法x，可以用最暴力的尝试</li>
<li>脑补出贪心策略A，贪心策略B，贪心策略C…</li>
<li>用解法x和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确</li>
<li>不要去纠结贪心策略的证明</li>
</ol>
</blockquote>
<ul>
<li>给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼接起来之后形成的字符串具有最小的字典序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestLexicography</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写比较器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (a + b).compareTo(b + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> MyComparator());</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            res += strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度20的金条，不管切成长度多大的两半，都需要花费20个铜板，怎么分最省？</p>
<p>例如：给定数组[10，20，30]，代表一共三个人，整块金条长度为10+20+30=60.金条要分成10，20，30三个部分，如果先把长度60的金条分成10和50，花费60，再把长度50的金条分成20和30，花费50，一共花费110铜板。但是如果先把长度为60的金条分成30和30，花费60，再把长度30金条分成10和20，花费30，一共花费90铜板。</p>
<p>输入一个数组，返回分割的最小代价</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LessMoneySplitedGold</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lessMoney</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pQ.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pQ.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cur = pQ.poll() + pQ.poll();</span><br><span class="line">            sum += cur;</span><br><span class="line">            pQ.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个宣讲最多的宣讲场次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestArrange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange</span><span class="params">(Program[] programs, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());<span class="comment">//按结束时间早晚排序</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &lt;= programs[i].start) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                start = programs[i].end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>输入：正数数组costs，正数数组profits,正数K,正数m，含义：costs[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费之后还能挣到的钱（利润）k表示你只能串行的最多做k个项目，m表示你的初始资金。说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。输出：你最后获得的最大钱数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> p;<span class="comment">//利润</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> c;<span class="comment">//花费</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.p = p;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.c - o2.c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfitComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.p - o1.p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> w, <span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] capital)</span> </span>&#123;</span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> Node[profits.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; profits.length; i++) &#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> Node(profits[i], capital[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建花费小根堆和利润大根堆</span></span><br><span class="line">        PriorityQueue&lt;Node&gt; minCostQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostComparator());</span><br><span class="line">        PriorityQueue&lt;Node&gt; maxProfitQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitComparator());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">            minCostQ.add(nodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= w) &#123;</span><br><span class="line">                maxProfitQ.add(minCostQ.poll());<span class="comment">//启动资金足够时，做该项目，并收获利益</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxProfitQ.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> w;<span class="comment">//任何一个项目都启动不了，直接退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            w += maxProfitQ.poll().p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一个数据流中，随时可以取得中位数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianQuick</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> MaxHeapComparator());</span><br><span class="line">        <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> MinHeapComparator());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyTwoHeapsSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//保持大小根堆分别有n/2个数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.maxHeap.size() == <span class="keyword">this</span>.minHeap.size() + <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.minHeap.add(<span class="keyword">this</span>.maxHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.minHeap.size() == <span class="keyword">this</span>.maxHeap.size() + <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maxHeap.add(<span class="keyword">this</span>.minHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek()) &#123;</span><br><span class="line">                maxHeap.add(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minHeap.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            modifyTwoHeapsSize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxHeapSize = <span class="keyword">this</span>.maxHeap.size();</span><br><span class="line">            <span class="keyword">int</span> minHeapSize = <span class="keyword">this</span>.minHeap.size();</span><br><span class="line">            <span class="keyword">if</span> (maxHeapSize + minHeapSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Integer maxHeapHead = <span class="keyword">this</span>.maxHeap.peek();</span><br><span class="line">            Integer minHeapHead = <span class="keyword">this</span>.minHeap.peek();</span><br><span class="line">            <span class="keyword">if</span> (((maxHeapSize + minHeapSize) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (maxHeapHead + minHeapHead) / <span class="number">2</span>;<span class="comment">//偶数个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//奇数个</span></span><br><span class="line">            <span class="keyword">return</span> maxHeapSize &gt; minHeapSize ? maxHeapHead : minHeapHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeapComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeapComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8、暴力递归"><a href="#8、暴力递归" class="headerlink" title="8、暴力递归"></a>8、暴力递归</h2><ul>
<li>暴力递归就是尝试<ol>
<li>把问题转化为规模缩小了的同类问题的子问题</li>
<li>有明确的不需要继续进行递归的条件（base case)</li>
<li>有当得到了子问题的结果后的决策过程</li>
<li>不记录每一个子问题的解</li>
</ol>
</li>
<li>汉诺塔：打印n层汉诺塔从最左边移动到最右边的全部过程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            func(n, n, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;mid&quot;</span>, <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> rest, <span class="keyword">int</span> down, String from, String help, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;move &quot;</span> + down + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            func(rest - <span class="number">1</span>, down - <span class="number">1</span>, from, to, help);</span><br><span class="line">            func(<span class="number">1</span>, down, from, help, to);</span><br><span class="line">            func(rest - <span class="number">1</span>, down - <span class="number">1</span>, help, from, to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>打印一个字符串的全部子序列，包括空字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintAllSubsquences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllSubsquence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        process(chs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == chs.length) &#123;</span><br><span class="line">            System.out.println(String.valueOf(chs));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(chs, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span> tmp = chs[i];</span><br><span class="line">        chs[i] = <span class="number">0</span>;</span><br><span class="line">        process(chs, i + <span class="number">1</span>);</span><br><span class="line">        chs[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给你一个栈,请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。如何实现？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseStackUsingRecursive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i = getAndRemoveLastElement(stack);</span><br><span class="line">		reverse(stack);</span><br><span class="line">		stack.push(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = stack.pop();</span><br><span class="line">		<span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> last = getAndRemoveLastElement(stack);</span><br><span class="line">			stack.push(result);</span><br><span class="line">			<span class="keyword">return</span> last;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行，不同列，也不在不一条斜线上。给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1，n=2或3，怎么摆都不行，返回0，n=8，返回92.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueens</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">return</span> process1(<span class="number">0</span>, record, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//i当前行，n终止行</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//走到终止行，完成一种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//遍历所有列</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(record, i, j)) &#123;<span class="comment">//如果合法就摆</span></span><br><span class="line">                record[i] = j;</span><br><span class="line">                res += process1(i + <span class="number">1</span>, record, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否能摆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;<span class="comment">//保证之前的行合法</span></span><br><span class="line">            <span class="keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(k - i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不同列，不在一条斜线上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化方法利用位移加速</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) &#123;<span class="comment">//超过32要换成long型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> upperLim = n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;<span class="comment">//二进制n位1</span></span><br><span class="line">        <span class="keyword">return</span> process2(upperLim, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> upperLim, <span class="keyword">int</span> colLim, <span class="keyword">int</span> leftDialLim, <span class="keyword">int</span> rightDialLim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colLim == upperLim) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">        pos = upperLim &amp; (~(colLim | leftDialLim | rightDialLim));<span class="comment">//可以摆的位置</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">            mostRightOne = pos &amp; (~pos + <span class="number">1</span>);<span class="comment">//取最右位的1摆</span></span><br><span class="line">            pos = pos - mostRightOne;<span class="comment">//还可以摆的位置</span></span><br><span class="line">            res += process2(upperLim, colLim | mostRightOne,</span><br><span class="line">                    (leftDialLim | mostRightOne) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                    (rightDialLim | mostRightOne) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Tryorish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tryorish</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/hai.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/09/%E6%AD%A5%E5%85%A5Linux%E7%9A%84%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95/"><img class="prev-cover" src="/img/yi.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">步入Linux的现代方法</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/09/hello-world/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tit.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tryorish</div><div class="author-info__description">风虽大，都绕过我灵魂</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tryorish/Tryorish.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tryorish/Tryorish.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%96%B0%E6%89%8B%E6%9D%91"><span class="toc-number">2.</span> <span class="toc-text">一、新手村</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">1、认识复杂度和简单排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AE%A4%E8%AF%86O-NlogN-%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、认识O(NlogN)的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%AF%A6%E8%A7%A3%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%8E%92%E5%BA%8F%E5%86%85%E5%AE%B9%E5%A4%A7%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">3、详解桶排序及排序内容大总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4、链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">5、二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%9B%BE"><span class="toc-number">2.6.</span> <span class="toc-text">6、图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%89%8D%E7%BC%80%E6%A0%91%E5%92%8C%E8%B4%AA%E5%BF%83"><span class="toc-number">2.7.</span> <span class="toc-text">7、前缀树和贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">2.8.</span> <span class="toc-text">8、暴力递归</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/30/java%E8%BF%9B%E9%98%B6/" title="java进阶"><img src="/img/java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java进阶"/></a><div class="content"><a class="title" href="/2022/06/30/java%E8%BF%9B%E9%98%B6/" title="java进阶">java进阶</a><time datetime="2022-06-30T05:43:48.000Z" title="发表于 2022-06-30 13:43:48">2022-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/31/JavaWeb%E7%AC%94%E8%AE%B0/" title="JavaWeb笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb笔记"/></a><div class="content"><a class="title" href="/2022/05/31/JavaWeb%E7%AC%94%E8%AE%B0/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-05-31T08:51:57.000Z" title="发表于 2022-05-31 16:51:57">2022-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/07/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/" title="字节青训营后端学习"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字节青训营后端学习"/></a><div class="content"><a class="title" href="/2022/05/07/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/" title="字节青训营后端学习">字节青训营后端学习</a><time datetime="2022-05-07T05:26:11.000Z" title="发表于 2022-05-07 13:26:11">2022-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/26/MySQL%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF/" title="MySQL从零到删库跑路"><img src="/img/MySQL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL从零到删库跑路"/></a><div class="content"><a class="title" href="/2022/04/26/MySQL%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF/" title="MySQL从零到删库跑路">MySQL从零到删库跑路</a><time datetime="2022-04-26T05:55:51.000Z" title="发表于 2022-04-26 13:55:51">2022-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机网络学习笔记"><img src="/img/er.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络学习笔记"/></a><div class="content"><a class="title" href="/2022/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机网络学习笔记">计算机网络学习笔记</a><time datetime="2022-04-13T02:35:24.000Z" title="发表于 2022-04-13 10:35:24">2022-04-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Tryorish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>